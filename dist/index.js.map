{"version":3,"file":"index.js","sources":["../webpack://local-cache/./lib/restore/index.js","../webpack://local-cache/webpack/runtime/compat","../webpack://local-cache/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        throw new Error('ðŸ”¥ This is a manual test error from v4.0.2');\n        // core.warning('Starting cache restoration process...')\n        // try {\n        //   /*\n        //     clean up caches\n        //   */\n        //   const cacheBase = core.getState('cache-base')\n        //   const cleanKey = core.getInput('clean-key')\n        //   const CLEAN_TIME = 7\n        //   if (cleanKey) {\n        //     await exec(\n        //       `/bin/bash -c \"find ${cacheBase} -maxdepth 1 -name '${cleanKey}*' -type d -atime +${CLEAN_TIME} -exec rm -rf {} +\"`\n        //     )\n        //   }\n        // } catch (error) {\n        //   if (error instanceof Error) core.warning(error.message)\n        // }\n        // try {\n        //   const key = core.getInput('key')\n        //   const base = core.getInput('base')\n        //   const path = core.getInput('path')\n        //   const cacheBase = getCacheBase(base)\n        //   const cachePath = getCachePath(key, base)\n        //   checkKey(key)\n        //   checkPaths([path])\n        //   core.saveState('key', key)\n        //   core.saveState('path', path)\n        //   core.saveState('cache-base', cacheBase)\n        //   core.saveState('cache-path', cachePath)\n        //   await exec(`mkdir -p ${cacheBase}`)\n        //   const find = await exec(\n        //     `find ${cacheBase} -maxdepth 1 -name ${key} -type d`\n        //   )\n        //   const cacheHit = find.stdout ? true : false\n        //   core.saveState('cache-hit', String(cacheHit))\n        //   core.setOutput('cache-hit', String(cacheHit))\n        //   core.info(`Path to cache: ${cachePath}`)\n        //   core.debug(`Path: ${path}`)\n        //   if (cacheHit === true) {\n        //     const ln = await exec(\n        //       `ln -s ${p.join(cachePath, path.split('/').slice(-1)[0])} ${path}`\n        //     )\n        //     core.debug(ln.stdout)\n        //     if (ln.stderr) core.error(ln.stderr)\n        //     if (!ln.stderr) core.info(`Cache restored with key ${key}`)\n        //   } else {\n        //     core.info(`Cache not found for ${key}`)\n        //   }\n        // } catch (error) {\n        //   if (error instanceof Error) core.setFailed(error.message)\n        // }\n    });\n}\nrun();\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[797](0, __webpack_exports__);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AClEA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}